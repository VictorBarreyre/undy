// NotificationDebugHelper.js
// Utilitaire pour tester et d√©boguer les notifications de conversation

import * as Notifications from 'expo-notifications';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { navigationRef } from '../../navigation/NavigationService';
import { getAxiosInstance } from '../../data/api/axiosInstance';

class NotificationDebugHelper {
  
  // Simuler une notification de message pour tester la navigation
  static async simulateMessageNotification(conversationId, senderName = "Test User") {
    console.log('[DEBUG] üß™ Simulation d\'une notification de message');
    console.log('[DEBUG] üìã ConversationId:', conversationId);
    
    try {
      // Donn√©es de notification similaires √† celles envoy√©es par le serveur
      const notificationData = {
        type: 'new_message',
        conversationId: conversationId,
        senderId: 'test-sender-id',
        senderName: senderName,
        messageType: 'text',
        timestamp: new Date().toISOString(),
        navigationTarget: 'Chat',
        navigationScreen: 'ChatTab',
        navigationParams: { conversationId }
      };
      
      // Envoyer la notification locale
      const identifier = await Notifications.scheduleNotificationAsync({
        content: {
          title: `Message de ${senderName}`,
          body: "Ceci est un message de test pour v√©rifier la navigation",
          data: notificationData,
          sound: true,
        },
        trigger: { 
          seconds: 2, // Dans 2 secondes
          repeats: false 
        }
      });
      
      console.log('[DEBUG] ‚úÖ Notification programm√©e avec ID:', identifier);
      console.log('[DEBUG] üì± Donn√©es de la notification:', JSON.stringify(notificationData, null, 2));
      
      return identifier;
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur lors de la simulation:', error);
      return null;
    }
  }
  
  // Tester avec une vraie notification du serveur
  static async testServerNotification(conversationId, testMessage = "Message de test serveur") {
    console.log('[DEBUG] üåê Test notification serveur...');
    console.log('[DEBUG] üìã ConversationId:', conversationId);
    
    try {
      const axiosInstance = getAxiosInstance();
      if (!axiosInstance) {
        console.error('[DEBUG] ‚ùå Instance Axios non disponible');
        return false;
      }

      // R√©cup√©rer les donn√©es utilisateur pour l'ID exp√©diteur
      const userDataStr = await AsyncStorage.getItem('userData');
      if (!userDataStr) {
        console.error('[DEBUG] ‚ùå Donn√©es utilisateur non trouv√©es');
        return false;
      }

      const userData = JSON.parse(userDataStr);
      const senderId = userData._id;
      const senderName = userData.name || "Utilisateur Test";

      console.log('[DEBUG] üë§ Exp√©diteur:', { senderId, senderName });

      // Appeler l'API du serveur pour envoyer une notification
      const response = await axiosInstance.post('/api/notifications/message', {
        conversationId: conversationId,
        senderId: senderId,
        senderName: senderName,
        messagePreview: testMessage,
        messageType: 'text'
      });

      console.log('[DEBUG] üì° R√©ponse serveur:', response.data);

      if (response.data.success) {
        console.log('[DEBUG] ‚úÖ Notification serveur envoy√©e avec succ√®s');
        console.log('[DEBUG] üìã D√©tails:', response.data.details);
        return true;
      } else {
        console.log('[DEBUG] ‚ùå √âchec notification serveur:', response.data.message);
        return false;
      }
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur test notification serveur:', error);
      if (error.response) {
        console.error('[DEBUG] üì° R√©ponse d\'erreur:', error.response.data);
      }
      return false;
    }
  }

  // Comparer les donn√©es de notification locale vs serveur
  static compareNotificationData() {
    console.log('[DEBUG] üîç COMPARAISON DES DONN√âES DE NOTIFICATION');
    
    // Structure ACTUELLE du serveur (apr√®s vos corrections)
    const serverNotificationStructure = {
      type: 'new_message',
      conversationId: 'string',
      senderId: 'string',
      senderName: 'string', // ‚úÖ MAINTENANT INCLUS
      messageType: 'text',
      timestamp: 'ISO string',
      // ‚úÖ MAINTENANT INCLUS AUSSI
      navigationTarget: 'Chat',
      navigationScreen: 'ChatTab',
      navigationParams: { conversationId: 'string' }
    };
  
    // Structure de votre notification locale de test
    const localNotificationStructure = {
      type: 'new_message',
      conversationId: 'string',
      senderId: 'test-sender-id',
      senderName: 'string',
      messageType: 'text',
      timestamp: 'ISO string',
      navigationTarget: 'Chat',
      navigationScreen: 'ChatTab',
      navigationParams: { conversationId: 'string' }
    };
  
    console.log('[DEBUG] üìã Structure serveur CORRIG√âE:', JSON.stringify(serverNotificationStructure, null, 2));
    console.log('[DEBUG] üìã Structure locale de test:', JSON.stringify(localNotificationStructure, null, 2));
    
    console.log('[DEBUG] ‚úÖ COMPARAISON APR√àS CORRECTIONS:');
    console.log('[DEBUG] 1. ‚úÖ La notification serveur INCLUT maintenant senderName');
    console.log('[DEBUG] 2. ‚úÖ La notification serveur INCLUT maintenant navigationTarget, navigationScreen, navigationParams');
    console.log('[DEBUG] 3. ‚úÖ Les structures locale et serveur sont maintenant IDENTIQUES !');
    console.log('[DEBUG] 4. üéØ Les deux types de notifications devraient maintenant fonctionner de la m√™me fa√ßon');
  }
  
  // AJOUTER aussi cette nouvelle m√©thode pour v√©rifier l'√©tat du serveur
  
  // V√©rifier que le serveur envoie bien les bonnes donn√©es
  static async verifyServerNotificationStructure(conversationId = null) {
    console.log('[DEBUG] üîç === V√âRIFICATION STRUCTURE SERVEUR R√âELLE ===');
    
    try {
      // 1. R√©cup√©rer une conversation r√©elle si n√©cessaire
      let realConversationId = conversationId;
      if (!realConversationId || realConversationId === "675a1234abcd5678efgh9012") {
        const conversations = await this.getRealConversations();
        if (conversations.length > 0) {
          realConversationId = conversations[0]._id;
        } else {
          console.log('[DEBUG] ‚ùå Aucune conversation trouv√©e');
          return false;
        }
      }
      
      // 2. Cr√©er un √©couteur temporaire pour capturer la structure exacte
      const verificationListener = Notifications.addNotificationResponseReceivedListener(response => {
        console.log('[DEBUG] üîî STRUCTURE SERVEUR CAPTUR√âE !');
        
        try {
          const content = response.notification.request.content;
          let data = content.data;
          
          // V√©rifier si les donn√©es sont dans content.data ou directement dans content
          if (!data || !data.type) {
            if (content.conversationId || content.type === 'new_message') {
              data = {
                type: content.type || 'new_message',
                conversationId: content.conversationId,
                senderId: content.senderId,
                senderName: content.senderName,
                messageType: content.messageType || 'text',
                timestamp: content.timestamp,
                navigationTarget: content.navigationTarget,
                navigationScreen: content.navigationScreen,
                navigationParams: content.navigationParams
              };
            }
          }
          
          console.log('[DEBUG] üìã DONN√âES SERVEUR R√âELLES CAPTUR√âES:');
          console.log(JSON.stringify(data, null, 2));
          
          // V√©rifier chaque champ important
          const fieldsToCheck = [
            'type', 'conversationId', 'senderId', 'senderName', 
            'messageType', 'timestamp', 'navigationTarget', 
            'navigationScreen', 'navigationParams'
          ];
          
          console.log('[DEBUG] ‚úÖ V√âRIFICATION DES CHAMPS:');
          fieldsToCheck.forEach(field => {
            const hasField = data && data[field] !== undefined;
            console.log(`[DEBUG] ${hasField ? '‚úÖ' : '‚ùå'} ${field}: ${hasField ? 'PR√âSENT' : 'MANQUANT'}`);
          });
          
          // Conclusion
          const hasAllFields = fieldsToCheck.every(field => data && data[field] !== undefined);
          if (hasAllFields) {
            console.log('[DEBUG] üéâ PARFAIT ! Le serveur envoie toutes les donn√©es n√©cessaires');
          } else {
            console.log('[DEBUG] ‚ö†Ô∏è Il manque encore des donn√©es c√¥t√© serveur');
          }
          
        } catch (error) {
          console.error('[DEBUG] ‚ùå Erreur analyse structure:', error);
        }
        
        // Nettoyer
        setTimeout(() => {
          Notifications.removeNotificationSubscription(verificationListener);
          console.log('[DEBUG] üßπ √âcouteur de v√©rification nettoy√©');
        }, 5000);
      });
      
      // 3. Envoyer une notification serveur pour capturer sa structure
      console.log('[DEBUG] üåê Envoi notification serveur pour v√©rification...');
      const result = await this.testServerNotification(
        realConversationId,
        "üîç V√©rification structure - CLIQUEZ pour analyser"
      );
      
      if (result) {
        console.log('[DEBUG] ‚úÖ Notification serveur envoy√©e');
        console.log('[DEBUG] üëÜ CLIQUEZ sur la notification pour voir la structure r√©elle !');
        return true;
      } else {
        console.log('[DEBUG] ‚ùå √âchec envoi notification serveur');
        return false;
      }
      
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur v√©rification structure:', error);
      return false;
    }
  }
  
  // AJOUTER cette m√©thode pour un test de comparaison en temps r√©el
  
  static async testRealTimeComparison(conversationId = null) {
    console.log('[DEBUG] üîÑ === TEST COMPARAISON EN TEMPS R√âEL ===');
    
    try {
      // 1. R√©cup√©rer une conversation r√©elle
      let realConversationId = conversationId;
      if (!realConversationId || realConversationId === "675a1234abcd5678efgh9012") {
        const conversations = await this.getRealConversations();
        if (conversations.length > 0) {
          realConversationId = conversations[0]._id;
        } else {
          console.log('[DEBUG] ‚ùå Aucune conversation trouv√©e');
          return false;
        }
      }
      
      console.log('[DEBUG] üéØ Conversation utilis√©e:', realConversationId);
      
      // 2. Variables pour stocker les donn√©es captur√©es
      let serverData = null;
      let localData = null;
      
      // 3. √âcouteur pour capturer les deux types
      const comparisonListener = Notifications.addNotificationResponseReceivedListener(response => {
        console.log('[DEBUG] üîî NOTIFICATION CAPTUR√âE POUR COMPARAISON');
        
        try {
          const content = response.notification.request.content;
          let data = content.data;
          
          // Reconstruction si n√©cessaire
          if (!data || !data.type) {
            if (content.conversationId || content.type === 'new_message') {
              data = {
                type: content.type || 'new_message',
                conversationId: content.conversationId,
                senderId: content.senderId,
                senderName: content.senderName,
                messageType: content.messageType || 'text',
                timestamp: content.timestamp,
                navigationTarget: content.navigationTarget,
                navigationScreen: content.navigationScreen,
                navigationParams: content.navigationParams
              };
            }
          }
          
          // Identifier le type de notification (serveur vs local)
          if (data?.senderId === 'test-sender-id') {
            console.log('[DEBUG] üì± NOTIFICATION LOCALE CAPTUR√âE');
            localData = data;
          } else {
            console.log('[DEBUG] üåê NOTIFICATION SERVEUR CAPTUR√âE');
            serverData = data;
          }
          
          // Si on a les deux, faire la comparaison
          if (serverData && localData) {
            console.log('[DEBUG] üîç === COMPARAISON COMPL√àTE ===');
            console.log('[DEBUG] üìã Donn√©es serveur:', JSON.stringify(serverData, null, 2));
            console.log('[DEBUG] üìã Donn√©es locales:', JSON.stringify(localData, null, 2));
            
            // Comparer chaque champ
            const fieldsToCompare = [
              'type', 'conversationId', 'messageType', 'timestamp',
              'senderName', 'navigationTarget', 'navigationScreen', 'navigationParams'
            ];
            
            console.log('[DEBUG] ‚öñÔ∏è COMPARAISON D√âTAILL√âE:');
            fieldsToCompare.forEach(field => {
              const serverHas = serverData[field] !== undefined;
              const localHas = localData[field] !== undefined;
              const match = serverHas === localHas;
              
              console.log(`[DEBUG] ${match ? '‚úÖ' : '‚ùå'} ${field}: Serveur=${serverHas}, Local=${localHas}`);
            });
            
            // Nettoyer
            setTimeout(() => {
              Notifications.removeNotificationSubscription(comparisonListener);
              console.log('[DEBUG] üßπ √âcouteur de comparaison nettoy√©');
            }, 2000);
          }
          
        } catch (error) {
          console.error('[DEBUG] ‚ùå Erreur comparaison:', error);
        }
      });
      
      // 4. Envoyer une notification serveur
      console.log('[DEBUG] üåê Envoi notification serveur...');
      await this.testServerNotification(realConversationId, "üîÑ Test comparaison serveur");
      
      // 5. Attendre puis envoyer une notification locale
      setTimeout(async () => {
        console.log('[DEBUG] üì± Envoi notification locale...');
        await this.simulateMessageNotification(realConversationId, "Test Comparaison");
        console.log('[DEBUG] üëÜ CLIQUEZ sur les deux notifications pour les comparer !');
      }, 8000);
      
      // 6. Nettoyage de s√©curit√©
      setTimeout(() => {
        if (comparisonListener) {
          Notifications.removeNotificationSubscription(comparisonListener);
          console.log('[DEBUG] üßπ Nettoyage de s√©curit√© effectu√©');
        }
      }, 30000);
      
      return true;
      
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur test comparaison:', error);
      return false;
    }
  }

  // Simuler les donn√©es exactes du serveur (pour comparaison)
  static async simulateExactServerNotification(conversationId, senderId, senderName = "Test Serveur") {
    console.log('[DEBUG] üé≠ Simulation EXACTE des donn√©es serveur...');
    
    try {
      // Donn√©es exactement comme le serveur les envoie (sans les champs suppl√©mentaires)
      const exactServerData = {
        type: 'new_message',
        conversationId: conversationId,
        senderId: senderId,
        messageType: 'text',
        timestamp: new Date().toISOString()
        // ATTENTION: Pas de senderName, navigationTarget, etc. comme le serveur
      };
      
      console.log('[DEBUG] üì° Donn√©es exactes du serveur:', JSON.stringify(exactServerData, null, 2));
      
      // Envoyer la notification avec les donn√©es exactes du serveur
      const identifier = await Notifications.scheduleNotificationAsync({
        content: {
          title: `Message de ${senderName}`, // Le titre vient du serveur
          body: "üé≠ Simulation exacte serveur - Cliquez pour tester",
          data: exactServerData, // Seulement les donn√©es que le serveur envoie
          sound: true,
        },
        trigger: { 
          seconds: 2,
          repeats: false 
        }
      });
      
      console.log('[DEBUG] ‚úÖ Notification avec donn√©es serveur exactes programm√©e:', identifier);
      return identifier;
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur simulation serveur exacte:', error);
      return null;
    }
  }

  // Test de l'√©couteur de notification avec donn√©es serveur exactes
  static async testNotificationListenerWithServerData(conversationId, senderId) {
    console.log('[DEBUG] üéß Test √©couteur avec donn√©es serveur exactes...');
    
    // Cr√©er un √©couteur temporaire pour ce test sp√©cifique
    const testListener = Notifications.addNotificationResponseReceivedListener(response => {
      console.log('[DEBUG] üîî √âCOUTEUR TEST SERVEUR D√âCLENCH√â !');
      console.log('[DEBUG] üìã Donn√©es re√ßues:', JSON.stringify(response.notification.request.content.data, null, 2));
      
      const data = response.notification.request.content.data;
      
      // V√©rifier si c'est notre test
      if (data?.type === 'new_message' && data?.conversationId === conversationId) {
        console.log('[DEBUG] ‚úÖ Donn√©es de test serveur d√©tect√©es !');
        console.log('[DEBUG] üéØ ConversationId:', data.conversationId);
        console.log('[DEBUG] üë§ SenderId:', data.senderId);
        console.log('[DEBUG] üìÖ Timestamp:', data.timestamp);
        
        // Test de navigation avec ces donn√©es exactes
        console.log('[DEBUG] üöÄ Test de navigation avec donn√©es serveur...');
        this.testDirectNavigation(data.conversationId);
      }
      
      // Nettoyer l'√©couteur apr√®s 10 secondes
      setTimeout(() => {
        Notifications.removeNotificationSubscription(testListener);
        console.log('[DEBUG] üßπ √âcouteur de test serveur nettoy√©');
      }, 10000);
    });
    
    // Envoyer la notification avec donn√©es serveur exactes
    setTimeout(async () => {
      await this.simulateExactServerNotification(conversationId, senderId, "Serveur Test");
    }, 1000);
    
    console.log('[DEBUG] ‚úÖ Test √©couteur avec donn√©es serveur lanc√©');
    console.log('[DEBUG] üì± Cliquez sur la notification qui va appara√Ætre !');
  }

  // R√©cup√©rer les vraies conversations de l'utilisateur
  static async getRealConversations() {
    console.log('[DEBUG] üîç R√©cup√©ration des vraies conversations...');
    
    try {
      const axiosInstance = getAxiosInstance();
      if (!axiosInstance) {
        console.error('[DEBUG] ‚ùå Instance Axios non disponible');
        return [];
      }

      const response = await axiosInstance.get('/api/secrets/conversations');
      console.log('[DEBUG] üìã R√©ponse conversations:', response.data);

      if (response.data && Array.isArray(response.data)) {
        const conversations = response.data.filter(conv => conv._id).slice(0, 5); // Prendre max 5 conversations
        console.log('[DEBUG] ‚úÖ Conversations trouv√©es:', conversations.map(c => ({
          id: c._id,
          name: c.name || 'Sans nom',
          participantsCount: c.participants?.length || 0
        })));
        return conversations;
      } else {
        console.log('[DEBUG] ‚ùå Format de r√©ponse inattendu');
        return [];
      }
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur r√©cup√©ration conversations:', error);
      return [];
    }
  }

  // Test complet avec notification serveur r√©elle
  static async testWithRealServerNotification(conversationId = null) {
    console.log('[DEBUG] üß™ ===== TEST AVEC NOTIFICATION SERVEUR R√âELLE =====');
    
    // 1. Si pas de conversationId fourni, essayer de r√©cup√©rer une vraie conversation
    let realConversationId = conversationId;
    
    if (!realConversationId || realConversationId === "675a1234abcd5678efgh9012") {
      console.log('[DEBUG] üîç ID de conversation factice d√©tect√©, r√©cup√©ration d\'une vraie conversation...');
      const conversations = await this.getRealConversations();
      
      if (conversations.length > 0) {
        realConversationId = conversations[0]._id;
        console.log('[DEBUG] ‚úÖ Utilisation de la conversation:', realConversationId);
        console.log('[DEBUG] üìã Nom de la conversation:', conversations[0].name || 'Sans nom');
      } else {
        console.log('[DEBUG] ‚ùå Aucune conversation trouv√©e, impossible de continuer');
        return false;
      }
    }
    
    // 2. Comparer les structures
    this.compareNotificationData();
    
    // 3. V√©rifier les permissions
    const hasPermissions = await this.checkNotificationPermissions();
    if (!hasPermissions) {
      console.log('[DEBUG] ‚ùå Test arr√™t√©: pas de permissions');
      return false;
    }
    
    // 4. V√©rifier l'√©tat de navigation
    const navState = this.debugNavigationState();
    if (!navState) {
      console.log('[DEBUG] ‚ùå Test arr√™t√©: navigation pas pr√™te');
      return false;
    }
    
    // 5. Nettoyer les navigations en attente
    await this.clearPendingNavigations();
    
    // 6. Envoyer une vraie notification via le serveur
    console.log('[DEBUG] üåê Envoi de notification via le serveur...');
    console.log('[DEBUG] üéØ ID de conversation utilis√©:', realConversationId);
    const serverResult = await this.testServerNotification(realConversationId, "üß™ Test serveur - Cliquez pour tester la navigation");
    
    if (serverResult) {
      console.log('[DEBUG] ‚úÖ Notification serveur envoy√©e');
      console.log('[DEBUG] üì± Une notification devrait appara√Ætre sur votre appareil');
      console.log('[DEBUG] üëÜ CLIQUEZ SUR LA NOTIFICATION pour tester la navigation');
      
      // Attendre et v√©rifier si la navigation se d√©clenche
      setTimeout(() => {
        console.log('[DEBUG] ‚è∞ Si vous avez cliqu√© sur la notification, vous devriez voir des logs de navigation maintenant...');
      }, 5000);
      
      return true;
    } else {
      console.log('[DEBUG] ‚ùå √âchec de l\'envoi de notification serveur');
      return false;
    }
  }
  
  // Tester la navigation directement sans notification
  static testDirectNavigation(conversationId) {
    console.log('[DEBUG] üß™ Test de navigation directe vers conversation:', conversationId);
    
    if (navigationRef.isReady()) {
      try {
        navigationRef.navigate('MainApp', {
          screen: 'Tabs',
          params: {
            screen: 'ChatTab',
            params: {
              screen: 'Chat',
              params: { conversationId },
            },
          },
        });
        console.log('[DEBUG] ‚úÖ Navigation directe r√©ussie');
        return true;
      } catch (error) {
        console.error('[DEBUG] ‚ùå Navigation directe √©chou√©e:', error);
        return false;
      }
    } else {
      console.log('[DEBUG] ‚ùå NavigationRef pas pr√™t');
      return false;
    }
  }
  
  // Afficher l'√©tat de navigation actuel
  static debugNavigationState() {
    console.log('[DEBUG] üîç Debug de l\'√©tat de navigation');
    
    if (navigationRef.isReady()) {
      try {
        const state = navigationRef.getState();
        console.log('[DEBUG] üìã √âtat complet:', JSON.stringify(state, null, 2));
        
        // Analyser la structure
        if (state && state.routes) {
          console.log('[DEBUG] üóÇÔ∏è Routes principales:');
          state.routes.forEach((route, index) => {
            console.log(`[DEBUG]   ${index}: ${route.name} (cl√©: ${route.key})`);
            if (route.state && route.state.routes) {
              console.log(`[DEBUG]     Sous-routes:`);
              route.state.routes.forEach((subRoute, subIndex) => {
                console.log(`[DEBUG]       ${subIndex}: ${subRoute.name}`);
              });
            }
          });
        }
        
        return state;
      } catch (error) {
        console.error('[DEBUG] ‚ùå Erreur lors du debug:', error);
        return null;
      }
    } else {
      console.log('[DEBUG] ‚ùå NavigationContainer pas pr√™t');
      return null;
    }
  }
  
  // V√©rifier les permissions de notification
  static async checkNotificationPermissions() {
    console.log('[DEBUG] üîç V√©rification des permissions de notifications');
    
    try {
      const { status } = await Notifications.getPermissionsAsync();
      console.log('[DEBUG] üìã Status des permissions:', status);
      
      if (status !== 'granted') {
        console.log('[DEBUG] ‚ö†Ô∏è Permissions non accord√©es, demande...');
        const { status: newStatus } = await Notifications.requestPermissionsAsync();
        console.log('[DEBUG] üìã Nouveau status:', newStatus);
        return newStatus === 'granted';
      }
      
      return true;
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur lors de la v√©rification:', error);
      return false;
    }
  }
  
  // V√©rifier s'il y a des navigations en attente
  static async checkPendingNavigations() {
    console.log('[DEBUG] üîç V√©rification navigations en attente');
    
    try {
      const keys = ['PENDING_NAVIGATION', 'EMERGENCY_NAVIGATION', 'PENDING_CONVERSATION_NAV'];
      
      for (const key of keys) {
        const value = await AsyncStorage.getItem(key);
        if (value) {
          console.log(`[DEBUG] üìã ${key}:`, JSON.parse(value));
        } else {
          console.log(`[DEBUG] ‚ùå ${key}: aucune donn√©e`);
        }
      }
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur lors de la v√©rification:', error);
    }
  }
  
  // Nettoyer toutes les navigations en attente
  static async clearPendingNavigations() {
    console.log('[DEBUG] üßπ Nettoyage des navigations en attente');
    
    try {
      const keys = ['PENDING_NAVIGATION', 'EMERGENCY_NAVIGATION', 'PENDING_CONVERSATION_NAV'];
      await AsyncStorage.multiRemove(keys);
      console.log('[DEBUG] ‚úÖ Navigations en attente nettoy√©es');
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur lors du nettoyage:', error);
    }
  }
  
  // Test complet de bout en bout
  static async runFullTest(conversationId) {
    console.log('[DEBUG] üß™ ===== TEST COMPLET DE NOTIFICATION =====');
    
    // 1. V√©rifier les permissions
    const hasPermissions = await this.checkNotificationPermissions();
    if (!hasPermissions) {
      console.log('[DEBUG] ‚ùå Test arr√™t√©: pas de permissions');
      return false;
    }
    
    // 2. V√©rifier l'√©tat de navigation
    const navState = this.debugNavigationState();
    if (!navState) {
      console.log('[DEBUG] ‚ùå Test arr√™t√©: navigation pas pr√™te');
      return false;
    }
    
    // 3. Nettoyer les navigations en attente
    await this.clearPendingNavigations();
    
    // 4. Tester la navigation directe
    console.log('[DEBUG] üß™ Test navigation directe...');
    const directNavResult = this.testDirectNavigation(conversationId);
    
    // Attendre un peu puis tester la notification
    setTimeout(async () => {
      console.log('[DEBUG] üß™ Test notification simul√©e...');
      await this.simulateMessageNotification(conversationId, "Test Notification");
    }, 3000);
    
    return true;
  }

  static async testServerWithClickDetection() {
    console.log('[DEBUG] üîç Test serveur avec d√©tection de clic...');
    
    // Variable pour tracker si on a re√ßu une notification
    let notificationReceived = false;
    let notificationData = null;
    
    // √âcouteur pour notification re√ßue
    const receivedListener = Notifications.addNotificationReceivedListener(notification => {
      console.log('[DEBUG] üì® NOTIFICATION RE√áUE !');
      const data = notification.request.content.data;
      
      if (data?.type === 'new_message') {
        notificationReceived = true;
        notificationData = data;
        console.log('[DEBUG] üíæ Donn√©es stock√©es pour clic:', data.conversationId);
        
        // Surveiller les clics pendant 30 secondes
        console.log('[DEBUG] üëÅÔ∏è Surveillance du clic activ√©e...');
        
        // Cr√©er un bouton temporaire pour simuler le clic
        setTimeout(() => {
          if (notificationReceived && notificationData) {
            console.log('[DEBUG] üéØ SIMULATION DU CLIC (navigation automatique)');
            this.testDirectNavigation(notificationData.conversationId);
          }
        }, 3000); // Navigation automatique apr√®s 3 secondes
      }
    });
    
    // √âcouteur pour clic r√©el (au cas o√π)
    const clickListener = Notifications.addNotificationResponseReceivedListener(response => {
      console.log('[DEBUG] üéâ CLIC R√âEL D√âTECT√â !');
      const data = response.notification.request.content.data;
      if (data?.conversationId) {
        this.testDirectNavigation(data.conversationId);
      }
    });
    
    // Envoyer la notification serveur
    const result = await this.testWithRealServerNotification();
    
    // Nettoyer apr√®s 30 secondes
    setTimeout(() => {
      Notifications.removeNotificationSubscription(receivedListener);
      Notifications.removeNotificationSubscription(clickListener);
      console.log('[DEBUG] üßπ √âcouteurs nettoy√©s');
    }, 30000);
    
    return result;
  }
  static async testServerNotificationWithNewFix(conversationId = null) {
    console.log('[DEBUG] üîß === TEST AVEC NOUVELLE CORRECTION APP.JS ===');
    
    try {
      // 1. S'assurer qu'on a une vraie conversation
      let realConversationId = conversationId;
      
      if (!realConversationId || realConversationId === "675a1234abcd5678efgh9012") {
        console.log('[DEBUG] üîç R√©cup√©ration d\'une vraie conversation...');
        const conversations = await this.getRealConversations();
        
        if (conversations.length > 0) {
          realConversationId = conversations[0]._id;
          console.log('[DEBUG] ‚úÖ Conversation r√©elle trouv√©e:', realConversationId);
        } else {
          console.log('[DEBUG] ‚ùå Aucune conversation trouv√©e');
          return false;
        }
      }
      
      // 2. Nettoyer toute navigation en attente
      const AsyncStorage = require('@react-native-async-storage/async-storage').default;
      await AsyncStorage.multiRemove([
        'PENDING_CONVERSATION_NAV',
        'EMERGENCY_NAVIGATION',
        'PENDING_NAVIGATION'
      ]);
      console.log('[DEBUG] üßπ Navigations en attente nettoy√©es');
      
      // 3. V√©rifier que le gestionnaire App.js est actif
      console.log('[DEBUG] üéß Le gestionnaire App.js devrait √™tre actif maintenant');
      console.log('[DEBUG] ‚ö†Ô∏è  IMPORTANT: V√©rifiez que vous voyez ces logs au d√©marrage:');
      console.log('[DEBUG]     - "[APP] üéß Configuration de l\'√©couteur global de notifications"');
      console.log('[DEBUG]     - "[APP] üöÄ NavigationContainer pr√™t!"');
      
      // 4. Envoyer la notification serveur
      console.log('[DEBUG] üåê Envoi de notification serveur avec conversation r√©elle...');
      const serverResult = await this.testServerNotification(
        realConversationId, 
        "üîß Test nouvelle correction - CLIQUEZ pour tester !"
      );
      
      if (serverResult) {
        console.log('[DEBUG] ‚úÖ Notification serveur envoy√©e avec succ√®s !');
        console.log('[DEBUG] üì± Une notification va appara√Ætre...');
        console.log('[DEBUG] üëÜ CLIQUEZ SUR LA NOTIFICATION pour tester');
        console.log('[DEBUG] üîç Regardez les logs pour voir:');
        console.log('[DEBUG]     1. "[APP] üîî === GESTIONNAIRE PRINCIPAL NOTIFICATION ==="');
        console.log('[DEBUG]     2. "[APP] ‚úÖ Notification de message valide d√©tect√©e"');
        console.log('[DEBUG]     3. "[APP] üéØ ConversationId: ' + realConversationId + '"');
        console.log('[DEBUG]     4. "[APP] üéâ Navigation notification r√©ussie !"');
        
        // 5. Programmer un test de notification locale pour comparer
        setTimeout(async () => {
          console.log('[DEBUG] üì± Envoi notification locale pour comparaison...');
          await this.simulateMessageNotification(realConversationId, "Test Local - Comparaison");
          console.log('[DEBUG] üëÜ CLIQUEZ aussi sur cette notification');
          console.log('[DEBUG] üéØ Les deux devraient maintenant fonctionner identiquement !');
        }, 15000); // 15 secondes apr√®s
        
        return true;
      } else {
        console.log('[DEBUG] ‚ùå √âchec envoi notification serveur');
        return false;
      }
      
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur dans le test:', error);
      return false;
    }
  }
  
  // M√©thode pour diagnostiquer l'√©tat actuel
  static async debugCurrentNotificationState() {
    console.log('[DEBUG] üîç === DIAGNOSTIC √âTAT NOTIFICATIONS ===');
    
    try {
      const AsyncStorage = require('@react-native-async-storage/async-storage').default;
      
      // 1. V√©rifier les navigations en attente
      const pendingKeys = ['PENDING_CONVERSATION_NAV', 'EMERGENCY_NAVIGATION', 'PENDING_NAVIGATION'];
      
      for (const key of pendingKeys) {
        const value = await AsyncStorage.getItem(key);
        if (value) {
          console.log(`[DEBUG] üìã ${key}:`, JSON.parse(value));
        } else {
          console.log(`[DEBUG] ‚úÖ ${key}: Aucune donn√©e en attente`);
        }
      }
      
      // 2. V√©rifier les permissions
      const { status } = await Notifications.getPermissionsAsync();
      console.log('[DEBUG] üîê Permissions notifications:', status);
      
      // 3. V√©rifier l'√©tat de navigation
      const { navigationRef } = require('../../navigation/NavigationService');
      if (navigationRef.isReady()) {
        console.log('[DEBUG] üöÄ NavigationRef: PR√äT');
        const state = navigationRef.getState();
        console.log('[DEBUG] üìç √âtat navigation actuel:', state?.routeNames || 'Indisponible');
      } else {
        console.log('[DEBUG] ‚ùå NavigationRef: PAS PR√äT');
      }
      
      // 4. Instructions pour le test
      console.log('[DEBUG] üìã === INSTRUCTIONS DE TEST ===');
      console.log('[DEBUG] 1. Assurez-vous que l\'app est active (foreground)');
      console.log('[DEBUG] 2. Utilisez testServerNotificationWithNewFix()');
      console.log('[DEBUG] 3. Cliquez sur la notification qui appara√Æt');
      console.log('[DEBUG] 4. V√©rifiez que vous √™tes redirig√© vers la conversation');
      console.log('[DEBUG] 5. Regardez les logs pour "[APP]" au lieu de "[DEEPLINK]"');
      
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur diagnostic:', error);
    }
  }
  
  // M√©thode pour forcer un test en arri√®re-plan
  static async testBackgroundNotificationBehavior(conversationId = null) {
    console.log('[DEBUG] üì± === TEST COMPORTEMENT ARRI√àRE-PLAN ===');
    
    try {
      // R√©cup√©rer une vraie conversation
      let realConversationId = conversationId;
      if (!realConversationId || realConversationId === "675a1234abcd5678efgh9012") {
        const conversations = await this.getRealConversations();
        if (conversations.length > 0) {
          realConversationId = conversations[0]._id;
        } else {
          console.log('[DEBUG] ‚ùå Aucune conversation trouv√©e');
          return false;
        }
      }
      
      console.log('[DEBUG] ‚è∞ Vous avez 10 secondes pour mettre l\'app en arri√®re-plan');
      console.log('[DEBUG] üì± Appuyez sur le bouton HOME maintenant !');
      
      // Attendre 10 secondes puis envoyer la notification
      setTimeout(async () => {
        console.log('[DEBUG] üåê Envoi notification serveur (app en arri√®re-plan)...');
        
        const result = await this.testServerNotification(
          realConversationId,
          "üåô Test arri√®re-plan - Cliquez pour revenir √† l'app !"
        );
        
        if (result) {
          console.log('[DEBUG] ‚úÖ Notification arri√®re-plan envoy√©e');
          console.log('[DEBUG] üëÜ Cliquez sur la notification pour revenir dans l\'app');
          console.log('[DEBUG] üéØ Vous devriez arriver directement sur la conversation');
        }
      }, 10000);
      
      return true;
      
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur test arri√®re-plan:', error);
      return false;
    }
  }
  
}



export default NotificationDebugHelper;